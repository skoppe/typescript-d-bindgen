import * as ir from './ir';
import { hasTypeGotHandle, mangleFunctionName, mangleMethod, FunctionKind, isVoid, isLiteralOrUndefinedType, getBindingType} from './utils'

export default function generateJsCode(declarations: ir.Declaration[], packageName: string) : string {
    const prefix = `// File is autogenerated with \`typescript-d-bindgen\`
import {spasm as spa, encoders as encoder, decoders as decoder} from '../modules/spasm.js';
const spasm = spa;
let memory = {};
const objects = spasm.objects;
const addObject = spasm.addObject;
const setupMemory = () => {
    let buffer = spasm.memory.buffer;
    if (memory.buffer == buffer)
        return;
    memory.buffer = buffer;
    memory.heapi32s = new Int32Array(buffer)
    memory.heapi32u = new Uint32Array(buffer)
    memory.heapi16s = new Int16Array(buffer)
    memory.heapi16u = new Uint16Array(buffer)
    memory.heapi8s = new Int8Array(buffer)
    memory.heapi8u = new Uint8Array(buffer)
    memory.heapf32 = new Float32Array(buffer)
    memory.heapf64 = new Float64Array(buffer)
}
const setBool = (ptr, val) => (memory.heapi32u[ptr/4] = +val),
      setInt = (ptr, val) => (memory.heapi32s[ptr/4] = val),
      setUInt = (ptr, val) => (memory.heapi32u[ptr/4] = val),
      setShort = (ptr, val) => (memory.heapi16s[ptr/2] = val),
      setUShort = (ptr, val) => (memory.heapi16u[ptr/2] = val),
      setByte = (ptr, val) => (memory.heapi8s[ptr] = val),
      setUByte = (ptr, val) => (memory.heapi8u[ptr] = val),
      setFloat = (ptr, val) => (memory.heapf32[ptr/4] = val),
      setDouble = (ptr, val) => (memory.heapf64[ptr/8] = val),
      getBool = (ptr) => memory.heapi32u[ptr/4],
      getInt = (ptr) => memory.heapi32s[ptr/4],
      getUInt = (ptr) => memory.heapi32u[ptr/4],
      getShort = (ptr) => memory.heapi16s[ptr/2],
      getUShort = (ptr) => memory.heapi16u[ptr/2],
      getByte = (ptr) => memory.heapi8s[ptr],
      getUByte = (ptr) => memory.heapi8u[ptr],
      getFloat = (ptr) => memory.heapf32[ptr/4],
      getDouble = (ptr) => memory.heapf64[ptr/8],
      isDefined = (val) => (val != undefined && val != null),
      encode_handle = (ptr, val) => { setUInt(ptr, spasm.addObject(val)); },
      decode_handle = (ptr) => { return spasm.objects[getUInt(ptr)]; },
      spasm_encode_string = encoder.string,
      spasm_decode_string = decoder.string,
      spasm_indirect_function_get = (ptr)=>spasm.instance.exports.__indirect_function_table.get(ptr),
  spasm_decode_Handle = decode_handle,
  spasm_decode_sequence = decode_handle;
`;
    const encoders = 'const customencoder = "";';
    const decoders = 'const customdecoder = "";';
    const exportOpening = `export let jsExports = { '${packageName}': {`
    const exports = declarations.map(declaration => {
        switch (declaration.declaration) {
            case 'function': return functionToString(declaration);
            case 'struct': return structToString(declaration);
        }
    }).filter(d => !!d).join(",\n");
    const exportClosing = `} };`
    return [prefix, encoders, decoders, exportOpening, exports, exportClosing].join("\n");
}

function templateArgumentsToString(arg: ir.Type[]) : string {
    if (arg.length == 0)
        return '';
    return `!(${arg.map(a => typeToString(a)).join(", ")})`;
}

function templateParameterToString( arg: ir.TemplateParameter): string {
    return arg;
}

function typeToString(type: ir.Type) : string {
    switch (type.type) {
        case 'intersection': return `IntersectionType!(${type.types.map(t => typeToString(t)).join(", ")})`;
        case 'union': return `UnionType!(${type.types.map(t => typeToString(t)).join(", ")})`
        case 'literalunion': return `OneOf!(${type.types.map(t => typeToString(t)).join(", ")})`;
        case 'reference': return `${type.name}${templateArgumentsToString(type.templateArguments)}`;
        case 'unknown': return "Unknown";
        case 'literal': return type.name;
        case 'keyword': return type.name;
        case 'array': return `uint, uint`;
        case 'mapped': return `Mapped`;
        case 'function': return `${typeToString(type.returnType)} delegate(${type.parameters.map(p => parameterToString(p)).join(", ")})`;
        case 'conditional': return `Conditional`;
        case 'optional': return `Optional!(${typeToString(type.baseType)})`;
        case 'indexed': return `GetMemberType!(${typeToString(type.indexType)}, ${typeToString(type.objectType)})`
        case 'predicate': return 'bool';
        case 'instantiated': return `${type.name}${templateArgumentsToString(type.templateArguments)}`;
        case 'handle': return 'Handle';
    }
    throw new Error(`Cannot map type ${type} to string`);
}

function templateParametersToString(args: ir.TemplateParameter[]) : string {
    if (args.length == 0)
        return '';
    return `(${args.map(t => templateParameterToString(t)).join(",")})`;
}

function parameterToString(param: ir.Parameter) : string {
    const bindingType = getBindingType(param.type)
    switch (bindingType.type) {
        case 'array': return `${param.name}Len, ${param.name}Off`
        case 'optional': return `${param.name}Defined, ${param.name}`
    }
    return `${param.name}`
}

function generateSourceDecoding(param: ir.Parameter) : string {
    if (hasTypeGotHandle(param.type))
        return `objects[${param.name}]`;
    if (canTypeBeReturned(param.type))
        return param.name;
    return decodeParameter(param);
}

function decodeParameter(param: ir.Parameter) : string {
    const decoder = getTypeDecoderName(param.type);
    switch (param.type.type) {
        case 'array': return `${decoder}(${param.name}Len, ${param.name}Off)`
        case 'optional': return `(${param.name}Defined ? ${param.name} : undefined)`
    }
    return `${decoder}(${param.name})`;
}

function generateFunctionParameterNames(returnType: ir.Type, params: ir.Parameter[]) : string[] {
    if (canTypeBeReturned(returnType))
        return params.map(parameterToString)
    return ['rawResult'].concat(params.map(parameterToString));
}

function mangleType(type: ir.Type) : string {
    // TODO: primitive types like int/float are simple as well
    switch (type.type) {
        case 'predicate': return 'predicate';
        case 'keyword':
            return type.name;
        case 'reference':
            const declaration = type.declaration()
            switch (declaration.declaration) {
                case 'struct':
                    return `${declaration.name}`; // TODO: mangle template args as well
                case 'alias':
                    return mangleType(declaration.type); // TODO: mangle template args as well
                case 'enum': return declaration.name;
                case 'typeparameter': return declaration.name; // TODO: what about this?
            }
            console.log(declaration);
            throw new Error("missing type mangler")
        case 'union': `union${type.types.length}_${type.types.map(mangleType).join("_")}`
        case 'intersection': `intersection${type.types.length}_${type.types.map(mangleType).join("_")}`
        case 'literalunion': return `literalunion_HASH`; // TODO: do the hash
        case 'mapped': return `mapped_`; // TODO: figure out mapped
        case 'optional': return `optional_${mangleType(type.baseType)}`;
        case 'function': return `function_`; // TODO: handle functions
        case 'unknown': return `unknown`; // TODO: can't actually happen, throw in future
        case 'literal': throw new Error("Cannot mangle literal types")
        case 'array': return `array_${mangleType(type.elementType)}`;
        case 'indexed': return `indexed_`; // TODO: probably should resolve indexed types earlier
    }
    console.log(type);
    throw new Error("missing type mangler")
}

function getTypeEncoderName(type: ir.Type) : string {
    return `spasm_encode_${mangleType(type)}`;
}

function getTypeDecoderName(type: ir.Type) : string {
    return `spasm_decode_${mangleType(type)}`;
}

function generateResultEncoding(returnType: ir.Type, expression: string) : string {
    if (isVoid(returnType)) {
        return expression;
    }
    if (hasTypeGotHandle(returnType))
        return `return addObject(${expression})`
    if (canTypeBeReturned(returnType))
        return `return ${expression}`;
    const encoder = getTypeEncoderName(returnType);
    return `${encoder}(rawResult, ${expression})`;
}

function canTypeBeReturned(type: ir.Type) : boolean {
    if (isVoid(type))
        return true;
    if (hasTypeGotHandle(type))
        return true;
    // TODO: primitive types like int/float are simple as well
    switch (type.type) {
        case 'predicate': return true;
        case 'keyword':
            switch (type.name) {
                case 'string': return false;
                case 'number': return true;
                case 'bool': return true;
                case 'double': return true;
            }
            break;
        case 'reference':
            const declaration = type.declaration()
            switch (declaration.declaration) {
                case 'struct': return true;
                case 'alias':
                    return canTypeBeReturned(declaration.type)
                case 'enum': return false; // TODO: is true when enum is number
            }
            break;
        case 'union':
        case 'intersection': // TODO: does intersection always require to be encoded?
        case 'literalunion':
            return false;
        case 'mapped': // TODO: does mapped need to be encoded?
            return false;
        case 'optional': return false;
        case 'function': return false; // TODO: handle functions
        case 'array': return false;
        case 'indexed': return true; // TODO: can it be returned?
    }
    console.log(type);
    throw new Error("missing case for canTypeBeReturned")
}

function structMemberToString(member: ir.StructMember, struct: ir.Struct) : string {
    const selfParameter: ir.Parameter = {name: 'ctx', type: {type: 'handle'}, optional: false}
    switch(member.memberType) {
        case 'property': {
            if (isLiteralOrUndefinedType(member.type))
                return;
            const getMangledName = mangleMethod(struct, member, [], FunctionKind.getter);
            const propertyParameter: ir.Parameter = {name: member.name, type: member.type, optional: false}
            const getLHS = `objects[ctx].${member.name}`;
            const getExpression = generateResultEncoding(member.type, getLHS);
            const getParameters = generateFunctionParameterNames(member.type, [selfParameter]).join(", ")
            const getter =
                `    ${getMangledName}: (${getParameters}) => {\n` +
                `        ${getExpression};\n`+
                `    }`
            const argument = functionParameterToArgument(propertyParameter)
            const setMangledName = mangleMethod(struct, member, [argument], FunctionKind.setter);
            const setLHS = `objects[ctx].${member.name}`;
            const setRHS = generateSourceDecoding(propertyParameter);
            const setter =
                `    ${setMangledName}: (ctx, ${parameterToString(propertyParameter)}) => {\n` +
                `        ${setLHS} = ${setRHS};\n`+
                `    }`
            return `${getter},\n${setter}`
        }
        case 'method':
            const bindingArguments = [functionParameterToArgument(selfParameter)].concat(member.parameters.map(functionParameterToArgument));
            const templateArguments = templateParametersToString(member.templateArguments);
            const parameters = generateFunctionParameterNames(member.returnType, member.parameters).join(", ")
            const mangledName = mangleMethod(struct, member, bindingArguments, FunctionKind.nomangle);
            const call = `objects[ctx].${member.name}(${member.parameters.map(generateSourceDecoding)})`;
            const expression = generateResultEncoding(member.returnType, call)
            return (`    ${mangledName}: (${parameters}) => {\n`+
                    `        ${expression};\n`+
                    `    }`);
    }
}

function structToString(struct : ir.Struct) {
    // TODO: handle templates
    let template = struct.templateArguments.map(t => templateParameterToString(t)).join(",")
    return struct.members.map(m => structMemberToString(m, struct)).filter(m => !!m).join(",\n");
}

function functionParameterToArgument(param: ir.Parameter) : ir.Argument {
    return {symbol: param.name, type: param.type}
}

function functionToString(func: ir.Function) : string {
    // TODO: wrap in template if templateParameters != null
    // const templateParameters = templateParametersToString(func.templateParameters);
    const bindingArguments = func.parameters.map(p => ({symbol: p.name, type: p.type}));
    const mangledName = mangleFunctionName(func.name, bindingArguments, FunctionKind.root);
    const parameters = generateFunctionParameterNames(func.returnType, func.parameters).join(", ")
    const call = `${func.name}(${func.parameters.map(generateSourceDecoding)})`;
    const expression = generateResultEncoding(func.returnType, call)
    return (`    ${mangledName}: (${parameters}) => {\n`+
            `        ${expression};\n`+
            `    }`);
}
